/* auto-generated by NAPI-RS */
/* eslint-disable */
/**
 * QUIC configuration
 *
 * This class holds configuration parameters that are shared across multiple
 * QUIC connections. It manages TLS certificates, transport parameters, and
 * protocol settings.
 */
export declare class Config {
  /**
   * Create a new Config with the specified QUIC version
   *
   * @param version - QUIC version (use PROTOCOL_VERSION constant)
   */
  constructor(version: number)
  /**
   * Load certificate chain from PEM file
   *
   * @param path - Path to PEM file containing certificate chain
   */
  loadCertChainFromPemFile(path: string): NapiResult<undefined>
  /**
   * Load private key from PEM file
   *
   * @param path - Path to PEM file containing private key
   */
  loadPrivKeyFromPemFile(path: string): NapiResult<undefined>
  /**
   * Set whether to verify peer's certificate
   *
   * @param verify - true to verify peer certificate (default: true)
   */
  verifyPeer(verify: boolean): void
  /**
   * Set application protocols (ALPN)
   *
   * @param protos - Buffer containing protocol identifiers
   *                 Format: length-prefixed strings (e.g., "\x02h3\x08http/1.1")
   *                 Use encodeAlpn() helper to create this from string array
   */
  setApplicationProtos(protos: Buffer): NapiResult<undefined>
  /**
   * Set max idle timeout in milliseconds
   *
   * @param timeout - Idle timeout in milliseconds (0 = no timeout)
   */
  setMaxIdleTimeout(timeout: number): void
  /**
   * Set initial maximum data (connection-level flow control)
   *
   * @param bytes - Maximum bytes that can be received on the connection
   */
  setInitialMaxData(bytes: number): void
  /**
   * Set initial maximum stream data for locally-initiated bidirectional streams
   *
   * @param bytes - Maximum bytes per stream
   */
  setInitialMaxStreamDataBidiLocal(bytes: number): void
  /**
   * Set initial maximum stream data for remotely-initiated bidirectional streams
   *
   * @param bytes - Maximum bytes per stream
   */
  setInitialMaxStreamDataBidiRemote(bytes: number): void
  /**
   * Set initial maximum stream data for unidirectional streams
   *
   * @param bytes - Maximum bytes per stream
   */
  setInitialMaxStreamDataUni(bytes: number): void
  /**
   * Set initial maximum number of bidirectional streams
   *
   * @param count - Maximum concurrent bidirectional streams
   */
  setInitialMaxStreamsBidi(count: number): void
  /**
   * Set initial maximum number of unidirectional streams
   *
   * @param count - Maximum concurrent unidirectional streams
   */
  setInitialMaxStreamsUni(count: number): void
  /**
   * Set congestion control algorithm
   *
   * @param algo - Algorithm to use (Reno, Cubic, or Bbr)
   */
  setCcAlgorithm(algo: CongestionControlAlgorithm): void
  /**
   * Enable early data (0-RTT)
   *
   * Allows the client to send application data in the first flight,
   * reducing connection establishment latency for resumed connections.
   */
  enableEarlyData(): void
  /**
   * Set the initial RTT (Round Trip Time) estimate
   *
   * @param rtt_ms - RTT in milliseconds
   */
  setInitialRtt(rttMs: number): void
  /**
   * Enable HyStart++ for congestion control
   *
   * HyStart++ improves slow start exit detection, reducing unnecessary packet loss.
   */
  enableHystart(enabled: boolean): void
  /**
   * Enable packet pacing
   *
   * Pacing spreads packet transmissions over time to reduce burstiness.
   */
  enablePacing(enabled: boolean): void
  /**
   * Set maximum pacing rate in bytes per second
   *
   * @param rate - Maximum pacing rate (0 = unlimited)
   */
  setMaxPacingRate(rate: number): void
  /**
   * Enable or disable QUIC datagrams.
   *
   * @param enabled - Whether to enable datagrams
   * @param recv_queue_len - Maximum number of datagrams to queue for receiving
   * @param send_queue_len - Maximum number of datagrams to queue for sending
   */
  enableDgram(enabled: boolean, recvQueueLen: number, sendQueueLen: number): void
}

/**
 * QUIC connection
 *
 * Represents a single QUIC connection with a peer. Handles packet I/O,
 * stream management, and connection lifecycle.
 */
export declare class Connection {
  /**
   * Create a client connection
   *
   * @param scid - Source Connection ID (Buffer, 1-20 bytes)
   * @param local - Local socket address (e.g., "127.0.0.1:0")
   * @param peer - Peer socket address (e.g., "127.0.0.1:4433")
   * @param config - QUIC configuration
   */
  static connect(scid: Buffer, local: string, peer: string, config: Config): NapiResult<Connection>
  /**
   * Accept a server connection
   *
   * @param scid - Source Connection ID (Buffer, 1-20 bytes)
   * @param odcid - Original Destination Connection ID (Buffer, optional)
   * @param local - Local socket address
   * @param peer - Peer socket address
   * @param config - QUIC configuration
   */
  static accept(scid: Buffer, odcid: Buffer | undefined | null, local: string, peer: string, config: Config): NapiResult<Connection>
  /**
   * Process incoming packet
   *
   * @param buf - Packet data
   * @param from - Sender's socket address
   * @returns Number of bytes processed
   */
  recv(buf: Buffer, from: string): NapiResult<number>
  /**
   * Generate outgoing packet
   *
   * @param out - Output buffer (must be at least 1200 bytes)
   * @returns Number of bytes written, or null if no packet to send
   */
  send(out: Buffer): NapiResult<number | undefined | null>
  /**
   * Send data on a stream
   *
   * @param stream_id - Stream ID
   * @param data - Data to send
   * @param fin - Whether this is the final data on the stream
   * @returns Number of bytes written
   */
  streamSend(streamId: number, data: Buffer, fin: boolean): NapiResult<number>
  /**
   * Receive data from a stream
   *
   * @param stream_id - Stream ID
   * @param out - Output buffer
   * @returns Object with { bytes: number, fin: boolean }
   */
  streamRecv(streamId: number, out: Buffer): NapiResult<StreamRecvResult>
  /** Check if connection is established */
  isEstablished(): boolean
  /** Check if connection is closed */
  isClosed(): boolean
  /** Check if connection is draining (closing) */
  isDraining(): boolean
  /** Check if connection is using 0-RTT early data */
  isInEarlyData(): boolean
  /** Check if connection was resumed from a previous session */
  isResumed(): boolean
  /** Check if connection has timed out */
  isTimedOut(): boolean
  /**
   * Get the error reported by the peer, if any
   *
   * @returns Error information, or null if no peer error
   */
  peerError(): ConnectionErrorInfo | null
  /**
   * Get the local error that caused connection closure, if any
   *
   * @returns Error information, or null if no local error
   */
  localError(): ConnectionErrorInfo | null
  /**
   * Close the connection
   *
   * @param app - Whether this is an application close
   * @param err_code - Error code to send to peer
   * @param reason - Reason phrase (Buffer)
   */
  close(app: boolean, errCode: number, reason: Buffer): NapiResult<undefined>
  /**
   * Get timeout duration in milliseconds
   *
   * @returns Milliseconds until next timeout event, or null if no timeout
   */
  timeout(): number | null
  /** Handle timeout event */
  onTimeout(): void
  /**
   * Enable QLOG logging to a file
   *
   * QLOG provides detailed connection event logging in JSON format for
   * debugging and performance analysis. Must be called early in connection
   * lifecycle to capture all events.
   *
   * @param path - File path for QLOG output (e.g., "/tmp/connection.qlog")
   * @param title - Log title
   * @param description - Log description
   */
  setQlog(path: string, title: string, description: string): NapiResult<undefined>
  /** Check if a stream is readable */
  streamReadable(streamId: number): boolean
  /**
   * Get next readable stream ID
   *
   * @returns Stream ID or null if no readable streams
   */
  streamReadableNext(): number | null
  /** Check if a stream is writable */
  streamWritable(streamId: number): boolean
  /**
   * Set stream priority (HTTP/3)
   *
   * Controls stream scheduling priority for HTTP/3 connections.
   *
   * @param stream_id - Stream ID to prioritize
   * @param urgency - Priority urgency (0-7, lower = higher priority)
   * @param incremental - Whether to use incremental delivery
   */
  streamPriority(streamId: number, urgency: number, incremental: boolean): NapiResult<undefined>
  /**
   * Get negotiated ALPN protocol
   *
   * @returns Protocol as Buffer, or null if not negotiated
   */
  applicationProto(): Buffer | null
  /**
   * Get the current Path MTU (Maximum Transmission Unit)
   *
   * @returns MTU in bytes, or null if not yet determined
   */
  pmtu(): number | null
  /**
   * Check if a network path is validated
   *
   * Path validation ensures that packets can be received from the peer
   * on the specified local and peer addresses.
   *
   * @param local - Local address (e.g., "127.0.0.1:4433")
   * @param peer - Peer address (e.g., "127.0.0.1:5000")
   * @returns true if path is validated, false otherwise
   */
  isPathValidated(local: string, peer: string): NapiResult<boolean>
  /** Check if this is a server-side connection */
  isServer(): boolean
  /**
   * Get the source connection ID
   *
   * @returns Source CID as Buffer
   */
  sourceId(): Buffer
  /**
   * Get the destination connection ID
   *
   * @returns Destination CID as Buffer
   */
  destinationId(): Buffer
  /**
   * Get peer's QUIC transport parameters
   *
   * Returns the transport parameters negotiated with the peer during
   * the handshake. Useful for debugging and interoperability testing.
   *
   * @returns Transport parameters, or null if not yet negotiated
   */
  peerTransportParams(): TransportParams | null
  /** Get connection statistics */
  stats(): Stats
  /**
   * Get per-path statistics
   *
   * @returns Array of PathStats objects
   */
  pathStats(): Array<PathStats>
  /**
   * Probe a new network path for connection migration
   *
   * Initiates path validation for a potential new network path. This is used
   * when the connection wants to migrate to different local/peer addresses
   * (e.g., switching from WiFi to cellular on mobile).
   *
   * @param local - New local address (e.g., "192.168.1.10:5000")
   * @param peer - New peer address (e.g., "10.0.0.1:4433")
   * @returns DCID sequence number for the path
   */
  probePath(local: string, peer: string): NapiResult<number>
  /**
   * Migrate connection to a new network path
   *
   * Switches the connection to use new local and peer addresses. This is
   * the primary method for connection migration (e.g., WiFi â†’ cellular).
   *
   * Note: Only clients can initiate migration (servers cannot).
   *
   * @param local - New local address (e.g., "10.0.0.5:6000")
   * @param peer - New peer address (e.g., "192.168.1.1:4433")
   * @returns DCID sequence number for the new path
   */
  migrate(local: string, peer: string): NapiResult<number>
  /**
   * Migrate connection to a new local address only
   *
   * Similar to migrate() but only changes the local address, keeping the
   * same peer address. Useful when local IP changes but peer stays the same.
   *
   * @param local - New local address (e.g., "10.0.0.5:6000")
   * @returns DCID sequence number for the new path
   */
  migrateSource(local: string): NapiResult<number>
  /**
   * Get number of available destination connection IDs
   *
   * Returns how many DCIDs are available for connection migration.
   * If this returns 0, migration may not be possible.
   *
   * @returns Number of available DCIDs
   */
  availableDcids(): number
  /**
   * Retire a destination connection ID
   *
   * Signals to the peer that a specific DCID should no longer be used.
   * This is part of the connection ID management during migration.
   *
   * @param dcid_seq - DCID sequence number to retire
   */
  retireDcid(dcidSeq: number): NapiResult<undefined>
  /**
   * Re-probe the Path MTU
   *
   * Triggers a new PMTU discovery process on the active path.
   * Useful after network changes or if you suspect MTU has changed.
   */
  revalidatePmtu(): void
  /**
   * Receive a QUIC datagram.
   *
   * @param buf - Buffer to receive datagram into
   * @returns Number of bytes read, or null if no datagram available
   */
  dgramRecv(buf: Buffer): NapiResult<number | undefined | null>
  /**
   * Send a QUIC datagram.
   *
   * @param buf - Datagram data to send
   */
  dgramSend(buf: Buffer): NapiResult<undefined>
  /**
   * Get the length of the first datagram in the receive queue.
   *
   * @returns Size in bytes, or null if queue is empty
   */
  dgramRecvFrontLen(): number | null
  /** Get the number of datagrams in the receive queue. */
  dgramRecvQueueLen(): number
  /** Get the total size of all datagrams in the receive queue. */
  dgramRecvQueueByteSize(): number
  /** Get the number of datagrams in the send queue. */
  dgramSendQueueLen(): number
  /** Get the total size of all datagrams in the send queue. */
  dgramSendQueueByteSize(): number
  /**
   * Get the maximum datagram size that can be sent.
   *
   * @returns Max datagram size in bytes, or null if datagrams not supported
   */
  dgramMaxWritableLen(): number | null
}

/** HTTP/3 configuration */
export declare class H3Config {
  /** Create a new H3 configuration */
  constructor()
  /** Set max field section size (header size limit) */
  setMaxFieldSectionSize(v: number): void
  /** Set QPACK max table capacity */
  setQpackMaxTableCapacity(v: number): void
  /** Set QPACK blocked streams */
  setQpackBlockedStreams(v: number): void
  /** Enable extended CONNECT protocol */
  enableExtendedConnect(enabled: boolean): void
}

/** HTTP/3 connection */
export declare class H3Connection {
  /**
   * Create HTTP/3 connection from QUIC transport connection
   *
   * Note: The QUIC connection must be established (or in early data for client)
   * before creating the HTTP/3 connection.
   */
  static withTransport(conn: Connection, config: H3Config): NapiResult<H3Connection>
  /**
   * Send an HTTP/3 request
   *
   * Returns the stream ID on which the request was sent.
   */
  sendRequest(conn: Connection, headers: Array<Header>, fin: boolean): NapiResult<number>
  /** Send an HTTP/3 response */
  sendResponse(conn: Connection, streamId: number, headers: Array<Header>, fin: boolean): NapiResult<undefined>
  /**
   * Send body data on a stream
   *
   * Returns the number of bytes written.
   */
  sendBody(conn: Connection, streamId: number, body: Buffer, fin: boolean): NapiResult<number>
  /**
   * Receive body data from a stream
   *
   * Returns the number of bytes read.
   */
  recvBody(conn: Connection, streamId: number, out: Buffer): NapiResult<number>
  /**
   * Poll for HTTP/3 events
   *
   * Returns an event object or null if no events are available.
   */
  poll(conn: Connection): NapiResult<H3Event | undefined | null>
  /** Check if connection is using NWEP protocol */
  isNwep(conn: Connection): boolean
}

/** Congestion control algorithms */
export declare const enum CongestionControlAlgorithm {
  /** Reno congestion control */
  Reno = 0,
  /** CUBIC congestion control (default) */
  Cubic = 1,
  /** BBR congestion control */
  Bbr = 2
}

/** Connection error information */
export interface ConnectionErrorInfo {
  /** Whether this is an application error (vs transport error) */
  isApp: boolean
  /** Error code */
  errorCode: number
  /** Human-readable reason */
  reason: string
}

/**
 * Encode ALPN protocols into wire format
 *
 * @param protocols - Array of protocol strings (e.g., ["h3", "http/1.1"])
 * @returns Buffer with length-prefixed protocols
 */
export declare function encodeAlpn(protocols: Array<string>): NapiResult<Buffer>

/**
 * Generate random connection ID
 *
 * @param len - Length in bytes (1-20)
 * @returns Buffer containing random bytes
 */
export declare function generateCid(len: number): NapiResult<Buffer>

/** HTTP/3 event from poll() */
export interface H3Event {
  /** Event type: "headers", "data", "finished", "reset", "priority_update", "goaway" */
  eventType: string
  /** Stream ID (for headers, data, finished, reset events) */
  streamId?: number
  /** Headers (for headers event) */
  headers?: Array<Header>
  /** Whether more frames follow (for headers event) */
  moreFrames?: boolean
  /** Error code (for reset event) */
  errorCode?: number
}

/** HTTP/3 header (name-value pair) */
export interface Header {
  name: Buffer
  value: Buffer
}

/**
 * Check if a buffer contains a valid QUIC version negotiation packet.
 *
 * @param buf - Packet buffer to check
 * @returns true if this is a version negotiation packet
 */
export declare function isVersionNegotiation(buf: Buffer): boolean

/** Maximum connection ID length */
export const MAX_CONN_ID_LEN: number

/** Minimum client initial packet length */
export const MIN_CLIENT_INITIAL_LEN: number

/** Result type alias for convenience */
export type NapiResult<T> =
  any

/**
 * Generate a version negotiation packet.
 *
 * @param scid - Source connection ID
 * @param dcid - Destination connection ID
 * @param out - Output buffer (must be at least 1200 bytes)
 * @returns Number of bytes written
 */
export declare function negotiateVersion(scid: Buffer, dcid: Buffer, out: Buffer): NapiResult<number>

/**
 * Get ALPN for NWEP/1 protocol
 *
 * @returns Buffer with NWEP ALPN (\x06nwep/1)
 */
export declare function nwepAlpn(): Buffer

/**
 * Get ALPN for both NWEP/1 and HTTP/3
 *
 * @returns Buffer with both NWEP and H3 ALPN
 */
export declare function nwepAndH3Alpn(): Buffer

export interface PacketHeader {
  packetType: PacketType
  version: number
  dcid: Buffer
  scid: Buffer
  token?: Buffer
  versions?: Array<number>
}

/** QUIC packet type. */
export declare const enum PacketType {
  /** Initial packet. */
  Initial = 'Initial',
  /** Retry packet. */
  Retry = 'Retry',
  /** Handshake packet. */
  Handshake = 'Handshake',
  /** 0-RTT packet. */
  ZeroRTT = 'ZeroRTT',
  /** Version negotiation packet. */
  VersionNegotiation = 'VersionNegotiation',
  /** 1-RTT short header packet. */
  Short = 'Short'
}

/**
 * Parse a QUIC packet header from a buffer.
 *
 * @param buf - The packet buffer to parse
 * @param dcid_len - Expected length of the destination connection ID (for short headers)
 * @returns Parsed header information
 */
export declare function parseHeader(buf: Buffer, dcidLen: number): NapiResult<PacketHeader>

/** Per-path QUIC statistics. */
export interface PathStats {
  /** The local address of the path. */
  localAddr: string
  /** The peer address of the path. */
  peerAddr: string
  /** The path validation state (Failed, Unknown, Validating, ValidatingMTU, or Validated). */
  validationState: string
  /** Whether the path is marked as active. */
  active: boolean
  /** The number of QUIC packets received. */
  recv: number
  /** The number of QUIC packets sent. */
  sent: number
  /** The number of QUIC packets that were lost. */
  lost: number
  /** The number of sent QUIC packets with retransmitted data. */
  retrans: number
  /** The number of times PTO (probe timeout) fired. */
  totalPtoCount: number
  /** The number of DATAGRAM frames received. */
  dgramRecv: number
  /** The number of DATAGRAM frames sent. */
  dgramSent: number
  /** The estimated round-trip time of the connection (in milliseconds). */
  rttMs: number
  /** The minimum round-trip time observed (in milliseconds). */
  minRttMs?: number
  /** The maximum round-trip time observed (in milliseconds). */
  maxRttMs?: number
  /**
   * The estimated round-trip time variation in samples using a mean
   * variation (in milliseconds).
   */
  rttvarMs: number
  /** The size of the connection's congestion window in bytes. */
  cwnd: number
  /** The number of sent bytes. */
  sentBytes: number
  /** The number of received bytes. */
  recvBytes: number
  /** The number of bytes lost. */
  lostBytes: number
  /** The number of stream bytes retransmitted. */
  streamRetransBytes: number
  /** The current PMTU for the connection. */
  pmtu: number
  /** The most recent data delivery rate estimate in bytes/s. */
  deliveryRate: number
  /** The maximum bandwidth estimate for the connection in bytes/s. */
  maxBandwidth?: number
  /** Statistics from when a CCA first exited the startup phase. */
  startupExit?: StartupExit
}

/** QUIC protocol version constant */
export const PROTOCOL_VERSION: number

/**
 * Generate a retry packet.
 *
 * @param scid - Original source connection ID
 * @param dcid - Original destination connection ID
 * @param new_scid - New source connection ID for retry
 * @param token - Retry token
 * @param version - QUIC version
 * @param out - Output buffer (must be at least 1200 bytes)
 * @returns Number of bytes written
 */
export declare function retry(scid: Buffer, dcid: Buffer, newScid: Buffer, token: Buffer, version: number, out: Buffer): NapiResult<number>

/** Statistics from when a CCA first exited the startup phase. */
export interface StartupExit {
  /** The congestion_window recorded at Startup exit. */
  cwnd: number
  /** The bandwidth estimate recorded at Startup exit (bytes per second). */
  bandwidth?: number
  /** The reason a CCA exited the startup phase. */
  reason: StartupExitReason
}

/** The reason a CCA exited the startup phase. */
export declare const enum StartupExitReason {
  /** Exit startup due to excessive loss. */
  Loss = 'Loss',
  /** Exit startup due to bandwidth plateau. */
  BandwidthPlateau = 'BandwidthPlateau',
  /** Exit startup due to persistent queue. */
  PersistentQueue = 'PersistentQueue'
}

/** QUIC connection statistics. */
export interface Stats {
  /** The number of QUIC packets received. */
  recv: number
  /** The number of QUIC packets sent. */
  sent: number
  /** The number of QUIC packets that were lost. */
  lost: number
  /** The number of QUIC packets that were marked as lost but later acked. */
  spuriousLost: number
  /** The number of sent QUIC packets with retransmitted data. */
  retrans: number
  /** The number of sent bytes. */
  sentBytes: number
  /** The number of received bytes. */
  recvBytes: number
  /** The number of bytes sent acked. */
  ackedBytes: number
  /** The number of bytes sent lost. */
  lostBytes: number
  /** The number of stream bytes retransmitted. */
  streamRetransBytes: number
  /** The number of DATAGRAM frames received. */
  dgramRecv: number
  /** The number of DATAGRAM frames sent. */
  dgramSent: number
  /** The number of known paths for the connection. */
  pathsCount: number
  /** The number of streams reset by local. */
  resetStreamCountLocal: number
  /** The number of streams stopped by local. */
  stoppedStreamCountLocal: number
  /** The number of streams reset by remote. */
  resetStreamCountRemote: number
  /** The number of streams stopped by remote. */
  stoppedStreamCountRemote: number
  /** The total number of PATH_CHALLENGE frames that were received. */
  pathChallengeRxCount: number
  /**
   * Total duration during which this side of the connection was
   * actively sending bytes or waiting for those bytes to be acked (in milliseconds).
   */
  bytesInFlightDurationMs: number
}

/** Stream receive result */
export interface StreamRecvResult {
  /** Number of bytes read */
  bytes: number
  /** Whether this is the final data */
  fin: boolean
}

/** Peer QUIC transport parameters */
export interface TransportParams {
  /** Maximum idle timeout in milliseconds */
  maxIdleTimeout: number
  /** Maximum UDP payload size */
  maxUdpPayloadSize: number
  /** Initial flow control max data for connection */
  initialMaxData: number
  /** Initial flow control max data for local bidirectional streams */
  initialMaxStreamDataBidiLocal: number
  /** Initial flow control max data for remote bidirectional streams */
  initialMaxStreamDataBidiRemote: number
  /** Initial flow control max data for unidirectional streams */
  initialMaxStreamDataUni: number
  /** Initial maximum bidirectional streams */
  initialMaxStreamsBidi: number
  /** Initial maximum unidirectional streams */
  initialMaxStreamsUni: number
  /** ACK delay exponent */
  ackDelayExponent: number
  /** Maximum ACK delay in milliseconds */
  maxAckDelay: number
  /** Whether active connection migration is disabled */
  disableActiveMigration: boolean
  /** Active connection ID limit */
  activeConnIdLimit: number
  /** Maximum datagram frame size (null if not supported) */
  maxDatagramFrameSize?: number
}
